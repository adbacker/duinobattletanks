2015 Boise Code Camp

intro (me!)


Lessons learned while building a pair of arduino-based battle tanks



What do they look like?
<demo video...or live presentation>










What we'll cover here...


Making large(ish) arduino projects manageable
==> alternate ide
==> existing IDE use
==> OO with arduino
Little bit about game flow/how I solved it

CODE! Making the tanks *go*.  (basic motor control)
CODE! Controlling the tank with the nrf24L01+ radios
CODE! Encoding values & transmitting/receiving Infrared signals
CODE! Transferring data arduino to arduino with the EasyTransfer serial library
CODE! Displaying data out to the user with (cheap!) I2C lcd displays














Original goals:

Tanks should identify who shot them and with what
Selectable weapons do differing amounts of damage
Multiple tank "shields"
Extendable to many tanks (more than just 2)


Eventually...
tanks communicate back to host computer
tanks with different balanced abilities
  more shields but slower
  different energy recharge rates
load tank configs by SD card
rumble feedback
sound effects
LASERS!  (because everything's better with lasers...)












---How I did it
https://flavorwire.files.wordpress.com/2012/06/howididit.jpg


Game flow, controller:
* read joystick, trigger
* send controller update to tank
* check for messages from tank (I wuz hit!)
* update lcd


Tank:
* check for network messages (controller updates)
* if firing, FIRE!
* update motor controller
* IRduino checks if we were hit (EasyTransfer -> softserial)
* if hit, send msg to controller












Lots of code...and the hardest code was code to *communicate*
  

tank <--> controller (2.4ghz radios)
tank1 <--> tank2 (IR beam)
user <-- tank (I2C LCD display)
tank1 <—-> tank1 (EasyTransfer serial)


Tank logic was trivial…hardware layer integration was much more challenging
beyond simple, trivial apps organization becomes more important
Processing (arduino’s code) is based on C/C++
Some gotchas here and there where full C++ OO isn’t…quite…all there
Some things you think *should* work…just don’t. (quite)















---Arduino OO 101 - Classes, variables, member functions

Define a header
note: all member functions (public or private) _must_ be in the header
define your member variables in here too
good to go with a convention: _myVariable is a local-to-the-class var
(with a nice color coding IDE not such a big deal)



---Oddities
strange compiler/linker behavior with parameterized constructors containing custom objects
[demo error -- Tank::Tank]
solution: add weird line to init objects on constructor line
-OR-
add a parameterless constructor (even if you don't use it)

Processing passes by value...so for objects init'ed in main, pointers are your friends





--super quick refresher on pointer notation, dereferencing, etc (SKIP ME!)

int a;  //a contains an integer value..
int* b; //b contains a _pointer_ (an address in memory) to an integer type

b = &a;  // &a says "give me the pointer to this variable"
         // not the var itself, but it's address in memory
         // so now b contains a's "address"
         // this is called "dereferencing a variable"  
         // dereference == 'get me the damn address of'

int c = *b; // *b means "show me what the pointer b is pointing _at_"
            //so c now contains whatever b was pointing at...


Odd behavior when accessing an object which is a property of an object













---Handy things to know/do

Syntax highlighting for larger projects is *very* nice...

If on windows, take a look at MS Visual Studio 2013 + VisualMicro!
[demo]

On mac, Sublime text with the arduino plugin works well




---MAKING THINGS MOVE
[motor control demo]








---CONTROLLING STUFF 
[RF24Network demo]








---SHOOTING STUFF
[IR demo]







---TALK AMONGST YOURSELVES
[EasyTransfer demo]

















---Highlights, controller

****LCD

define:
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

// Set the pins on the I2C chip used for LCD connections:
//                    addr, en,rw,rs,d4,d5,d6,d7,bl,blpol
LiquidCrystal_I2C lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);  // Set the LCD I2C address

setup:
lcd.begin(20,2); // initialize the lcd for 20 chars 4 lines and turn on backlight

writing:
lcd.setCursor(0,0);
lcd.print("This is a test");
lcd.setCursor(0,1);
lcd.print("this is only a test");


Notes:
remove existing lcd libraries from arduino! (else weird errors)

use i2c scan app to discover lcd's i2c address (not always what is advertised)
http://gammon.com.au/i2c 

constant updating will cause flicker
easy way to fix that, only update every 100 milliseconds:

if (millis() % 100 == 0) {
	lcd.setCursor(0,0);
	lcd.print("msg line 1 goz here");
  lcd.setCursor(0,1);
  lcd.print("msg line 2 goz here");
}



****RF24network

define:

#include <RF24Network.h>
#include <RF24.h>
#include <SPI.h>

#define CE_PIN   9 //these can differ
#define CSN_PIN 10 //I tested 7 and 8 and they worked
RF24 radio(CE_PIN, CSN_PIN); // Create a Radio
// Network uses that radio
RF24Network network(radio);
// Address of our node
const uint16_t this_node = 0;
// Address of the other node
const uint16_t other_node = 1;


A NOTE ON NODES...
node 00 is root
nodes 01 - 05 are children
node 012 is the first child of node 02
node 0312 is the third child of node 012

a node, coming up, will need to find it's parent
so address appropriately!
(eg: someone will need to have node 00 as it's parent)


setup:
SPI.begin();
radio.begin();
network.begin(/*channel*/ 90, /*node address*/ this_node);
struct controller {
	long encodedShot;
	int xval;
	int yval;
}

using:
//put this in your main loop:
network.update();     // Pump the network regularly

--sending

int controller[3];


controller[0] = xval; //x throttle value
controller[1] = yval; //y throttle value
controller[2] = encodedShot; //0 if not firing, 
//send our controller values
RF24NetworkHeader header(/*to node*/ other_node);
bool ok = network.write(header,&controller,sizeof(controller));
if (ok)
  Serial.println("ok.");
else
  Serial.println("failed.");


--receiving
  while ( network.available() )
  {
    // If so, grab it and print it out
    RF24NetworkHeader header;
    network.read(header,&controller,sizeof(controller));
  }
  long xval = controller[0];
  int yval = controller[1];
  
  if (controller[0] !=0 || controller[1] !=0)
  {
    //throttlemix(controller[0],controller[1]);
  }



--MISC:
POWER!  with one usb plugged in and 2 arduinos connected, one will sponge off another, not enough power to run everything (example: ir ports not working...)




---LIBRARIES USED---

**IRremote
infrared transmitter/receiver library for arduino
http://www.righto.com/2009/08/multi-protocol-infrared-remote-library.html

use _this_ fork if you're going to do multiple IR receivers...it's the only one I found
to work reliably: https://github.com/skbrii/IRremote



**RF24Network
home: http://maniacbug.github.io/RF24Network/
src: https://github.com/maniacbug/RF24Network
using inexpensive nRF24L01(+) radios easily (cheap alternative to zigbee)
cool tip: a tcp/ip stack (sorta) for these things is available: http://embeddedcoolness.com/home/



**EasyTransfer -- Arduino to Arduino communication
home: http://www.billporter.info/2011/05/30/easytransfer-arduino-library/
src: https://github.com/madsci1016/Arduino-EasyTransfer
I2C, software serial, virtualwire versions
If using an I2C lcd, *that* arduino *has* to be the master...and there are oddities for
who can send/receive between master and slave.  (so I used software serial)



**I2C Lcd
somewhat specific to the i2c chipset
the super-cheap $1 I2C to LCD adapters I bought on ebay needed this particular advice:
http://forum.arduino.cc/index.php?topic=157817.0
which references this page:
http://arduino-info.wikispaces.com/LCD-Blue-I2C



--SOFTWARE TOOLS--
Visual Studio Community Edition: https://www.visualstudio.com/en-us/news/vs2013-community-vs.aspx
Visual Micro (plugin for ^^) http://www.visualmicro.com/

On mac:
Xcode (free, app store!) with embedXcode http://playground.arduino.cc/Main/EmbedXcode
Sublime Text ( http://www.sublimetext.com/ ) with Stino arduino plugin ( https://github.com/Robot-Will/Stino )


--PARTS--
arduino uno clones:
--note about USB chipsets..
for windows, linux, and mac, you'll need to find and install the CH340G USB Driver for these to work.
easiest way...go here:
https://github.com/bgaultier/laboite-webapp
download the archive as a .zip
use ch341ser_mac.zip for mac, CH341SER.EXE for windows

ebay: search "arduino uno"
amazon:


arduino nano clones:
--see note above re: usb chipsets
ebay: search "arduino nano"


arduino pro minis:
ebay: search "arduino pro mini"
--notes:
you'll need a usb-to-serial converter (below)
watch out..some are 5v, some are 3.3v, and some can do either.


usb-to-serial converter:
ebay:
amazon($5): http://www.amazon.com/gp/product/B009T2ZR6W/ref=oh_aui_detailpage_o01_s00?ie=UTF8&psc=1
--will need drivers for CP2102 chipset!
adafruit($17): http://www.adafruit.com/product/70


LCDs:
ebay(from $2): search for "LCD 1602 16x2"

I2C backpack for LCD:
ebay (from $1): search "LCD I2C" *THEN* select buy it now and sort by price+shipping, lowest first.  Should be some for < $1 with shipping...


nRF24L01 radios
ebay & amazon: search "nrf24l01"

robot chassis
amazon: search "robot chassis"
"better" tank chassis ~ possibly one of these:http://www.tamiyausa.com/items/geniuseries-educational-kits-50/educational-construction-38000/tracked-vehicle-chassis-kit-70108
paired with their dual motor: http://www.tamiyausa.com/items/geniuseries-educational-kits-50/educational-construction-38000/double-gearbox-70168

L298D motor controllers
ebay & amazon: search "L298 motor controller"

IR Leds:
ebay: search "IR LED 940"
amazon:
tayda electronics($0.06ea): http://www.taydaelectronics.com/infrared-led-940nm-5mm-tsal7400.html


IR Receivers:
ebay: search "IR receiver" in Business and Industrial
amazon:
tayda electronics($0.66ea): http://www.taydaelectronics.com/ir-receiver-module-38-khz-tsop4838.html




 