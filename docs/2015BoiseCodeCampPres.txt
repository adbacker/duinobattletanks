2015 Boise Code Camp

Lessons learned while building a pair of arduino-based battle tanks


What do they look like?
<demo>


Original goals:
Tanks should identify who shot them and with what
Selectable weapons do differing amounts of damage
Multiple tank "shields"
Extendable to many tanks (more than just 2)
Eventually tanks communicate back to host computer?

Lots of code...and the hardest code was code to *communicate*
  
tank <--> controller (2.4ghz radios)
tank1 <--> tank2 (IR beam)
user <-- tank (I2C LCD display)
tank1 <—-> tank1 (EasyTransfer serial)

Tank logic was trivial…hardware layer integration was much more challenging


---Code structure:

beyond simple, trivial apps organization becomes more important
Processing (arduino’s code) is based on C/C++
Some gotchas here and there where full C++ OO isn’t…quite…all there
Some things you think *should* work…just don’t. (quite)

---Arduino OO 101 - Classes, variables, member functions

Define a header
note: all member functions (public or private) _must_ be in the header
define your member variables in here too
good to go with a convention: _myVariable is a local-to-the-class var
(with a nice color coding IDE not such a big deal)

---Oddities
strange compiler/linker behavior with parameterized constructors containing custom objects
[demo error -- Tank::Tank]
solution: add weird line to init objects on constructor line
-OR-
add a parameterless constructor as well

Processing passes by value...so for objects init'ed in main, pointers are your friends
--refresher on pointer notation, dereferencing, etc

Odd behavior when accessing an object which is a property of an object

---Handy things to know/do
If on windows, take a look at MS Visual Studio 2013 + VisualMicro!
[demo]


---How I did it
[insert Young Frankenstein pic]
https://flavorwire.files.wordpress.com/2012/06/howididit.jpg

Game flow, controller:
* read joystick, trigger
* send controller update to tank
* check for messages from tank (I wuz hit!)
* update lcd



Tank:
* check for network messages (controller updates)
* if firing, FIRE!
* update motor controller
* check if we were hit (EasyTransfer -> softserial from IRduino)
* if hit, send msg to controller


---Highlights, controller

****LCD

define:
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

// Set the pins on the I2C chip used for LCD connections:
//                    addr, en,rw,rs,d4,d5,d6,d7,bl,blpol
LiquidCrystal_I2C lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);  // Set the LCD I2C address


setup:
lcd.begin(20,2); // initialize the lcd for 20 chars 4 lines and turn on backlight


writing:
lcd.setCursor(0,0);
lcd.print("This is a test");
lcd.setCursor(0,1);
lcd.print("this is only a test");


Notes:
use i2c scan app to discover lcd's i2c address (not always what is advertised)

constant updating will cause flicker
easy way to fix that, only update every 100 milliseconds:

if (millis() % 100 == 0) {
	lcd.setCursor(0,0);
	lcd.print("msg goz here");
}






****RF24network

define:

#include <RF24Network.h>
#include <RF24.h>
#include <SPI.h>

#define CE_PIN   9 //these can differ
#define CSN_PIN 10 //I tested 7 and 8 and they worked
RF24 radio(CE_PIN, CSN_PIN); // Create a Radio
// Network uses that radio
RF24Network network(radio);
// Address of our node
const uint16_t this_node = 0;
// Address of the other node
const uint16_t other_node = 1;


A NOTE ON NODES...
node 00 is root
nodes 01 - 05 are children
node 012 is the first child of node 02
node 0312 is the third child of node 012

a node, coming up, will need to find it's parent
so address appropriately!
(eg: someone will need to have node 00 as it's parent)


setup:
SPI.begin();
radio.begin();
network.begin(/*channel*/ 90, /*node address*/ this_node);
struct controller {
	long encodedShot;
	int xval;
	int yval;
}

using:
//put this in your main loop:
network.update();     // Pump the network regularly

--sending

int controller[3];


controller[0] = xval; //x throttle value
controller[1] = yval; //y throttle value
controller[2] = encodedShot; //0 if not firing, 
//send our controller values
RF24NetworkHeader header(/*to node*/ other_node);
bool ok = network.write(header,&controller,sizeof(controller));
//if (ok)
//  Serial.println("ok.");
//else
//  Serial.println("failed.");


--receiving
  while ( network.available() )
  {
    // If so, grab it and print it out
    RF24NetworkHeader header;
    network.read(header,&controller,sizeof(controller));
  }
  long xval = controller[0];
  int yval = controller[1];
  
  if (controller[0] !=0 || controller[1] !=0)
  {
    //throttlemix(controller[0],controller[1]);
  }






---LIBRARIES USED---

**IRremote
infrared transmitter/receiver library for arduino
http://www.righto.com/2009/08/multi-protocol-infrared-remote-library.html

use _this_ fork if you're going to do multiple IR receivers...it's the only one I found
to work reliably: https://github.com/skbrii/IRremote



**RF24Network
home: http://maniacbug.github.io/RF24Network/
src: https://github.com/maniacbug/RF24Network
using inexpensive nRF24L01(+) radios easily (cheap alternative to zigbee)
cool tip: a tcp/ip stack (sorta) for these things is available: http://embeddedcoolness.com/home/



**EasyTransfer -- Arduino to Arduino communication
home: http://www.billporter.info/2011/05/30/easytransfer-arduino-library/
src: https://github.com/madsci1016/Arduino-EasyTransfer
I2C, software serial, virtualwire versions
If using an I2C lcd, *that* arduino *has* to be the master...and there are oddities for
who can send/receive between master and slave.  (so I used software serial)



**I2C Lcd
somewhat specific to the i2c chipset
the super-cheap $1 I2C to LCD adapters I bought on ebay needed this particular advice:
http://forum.arduino.cc/index.php?topic=157817.0
which references this page:
http://arduino-info.wikispaces.com/LCD-Blue-I2C


 